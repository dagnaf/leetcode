# tutorial

- 解法1

https://codeforces.com/blog/entry/93898?#comment-829111

f1、f2都先算出可以和节点1相连的节点，根据d1结论，连接顺序并不影响最后结果。连接后，分别记在f1、f2中，与节点1在同一树中的节点集合为p1、p2，而取反集合记为p1_bar、p2_bar。可以得到p2一定包含p1_bar，而p1一定包含p2_bar。所有节点可以被分为3个集合：1、仅与f1中的节点1在同一树中；2、同时与f1、f2中的节点1在同一树中；3、仅与f2中的节点在同一树中。要继续新增加边，则只可能在第1、3节点集合中各选一个节点相连。而任取f1中的x、f2中的y，如果可以添加边，那么x就从集合1移动到集合2，y从集合3移动到集合2。因此，最终就是依次遍历连接p1_bar、p2_bar的节点。

- 解法2

https://codeforces.com/blog/entry/93898

用二维数组t[x][y]表示同时在f1中的树x、f2中的树y的节点集合，那么非同行、非同列的(x1,y1)、(x2,y2)集合可以合并。合并过程是行列合并，将元素少的合并到多的，维度减少一。维护行元素数量，从数量小的开始合并，最多n次合并（2n次行和列），每次合并可以通过set判断是否可以合并，每次合并后通过set维护元素数量。